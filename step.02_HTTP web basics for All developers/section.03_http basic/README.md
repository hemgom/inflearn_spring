# 섹션 03. HTTP 기본
## 01. 모든 것이 HTTP (HyperText Transfer Protocol)
### HTTP 메시지에 모든 것을 전송
- HTML, TEXT
- 이미지, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터들을 전송 가능
- 서버간 데이터를 주고 받을 떄도 대부분 HTTP 사용
- 바야흐로 대 HTTP 시대!  
<br/>

### HTTP 역사
- `HTTP/0.9` (1991) : GET 메서드만 지원
- `HTTP/1.0` (1996) : 메서드, 헤더 추가
- `HTTP/1.1` (1997) : __가장 많이 사용하는 버전 (= 중요한 버전)__
	- RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- `HTTP/2` (2015) : 성능 개선
- `HTTP/3` (개발중) : TCP 대신 UDP 사용, 성능 개선  
<br/>

### 기반 프로토콜
- `TCP` : HTTP/1.1 ~ HTTP/2
	- `TCP` 자체가 속도에 최적화 된 프로토콜이 아님
- `UDP` : HTTP/3
- 현재 `HTTP/1.1`을 주로 사용
	- 하지만 `HTTP/2` `HTTP/3`도 점점 증가 추세  
<br/>

### HTTP 특징
- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능  
<br/><br/><br/>

## 02. 클라이언트 서버 구조
- Request & Response 구조
- 클라이언트는 서버에 요청을 보내고 응답을 대기함
- 서버가 요청에 대한 결과를 만들어 응답
- 사실 클라이언트와 서버를 분리했다는게 중요!  
<br/><br/><br/>

## 03. Stateful, Stateless
### Stateful과 Stateless의 차이
#### Stateful의 경우 - 상태 유지
- 예제
	- 고객 : 노트북 얼마인가요?
	- 점원 : 100만원 입니다. __(노트북 상태 유지)__
	- 고객 : 2개 구매 할 수 있을까요?
	- 점원 : 네! 200만원 입니다. 결제를 뭐로 하시겠어요? __(노트북, 2개 상태 유지)__
	- 고객 : 신용카드로 결제 할게요.
	- 점원 : 네 결제 완료 되었습니다. __(노트북, 2개, 신용카드 상태 유지)__
- 우리가 아는 흔한 일상 대화이다.  
<br/>

#### Stateless의 경우 - 무상태
- 예제
	- 고객 : __노트북__ 얼마인가요?
	- 점원(1) : 100만원 입니다.
	- 고객 : __노트북 2개__ 구매 할 수 있을까요?
	- 점원(2) : 네! 200만원 입니다. 결제를 뭐로 하시겠어요?
	- 고객 : __노트북 2개 신용카드로__ 결제 할게요.
	- 점원(3) : 네 결제 완료 되었습니다.
- 고객이 말하는 내용이 점차 늘어나지만 예제처럼 점원이 바뀌어도 일처리에 문제가 없음  
<br/>

### Stateless(스테이트리스) - 무상태 프로토콜
- 서버가 클라이언트의 상태를 보존하지 않음
	- 장점 : 서버의 확장성이 높음 (스케일 아웃)
	- 단점 : 클라이언트가 추가 데이터 전송  
<br/>

### 정리
- `상태 유지(Stateful)` : 중간에 다른 점원으로 바뀌면 안됨!
- `무상태(Stateless)` : 중간에 다른 점원으로 바뀌어도 상관 없음!
	- 갑자기 고객이 많아져도 점원만 추가하면 됨
		- 즉, 클라이언트 수가 급격하게 많아져도 서버만 추가하면 된다.
- `Stateless`의 경우 응답 서버를 쉽게 바꿀 수 있음
	- (이론상)무한한 서버 증설 가능!!
- 중간에 서버가 장애가 난다면?
	- `Stateful`의 경우 요청을 처음부터 다시 작성해야함
	- `Stateless`의 경우 기존 요청을 다른 서버에게 건네주기만 하면 됨
		- 이러한 점 때문에 `Stateless`의 경우 `스케일 아웃(수평 확장)`이 유리하다!
- `Stateless`의 실무 한계
	- 모든 것을 무상태로 설계 할 수 있는 경우가 있고 없는 경우가 있다는 점
		- ex) 로그인이 필요없는 안내 페이지 (무상태)
		- ex) 로그인 해야 참여가 가능한 페이지 (상태 유지)
	- 로그인한 사용자의 상태를 서버에 유지를 해야함
		- 그렇기에 `브라우저 쿠키`와 `서버 세션`등을 사용해 상태를 유지함
	- 또한 상태 유지를 최소한만 사용해야함
		- 이전에 예시를 들었던 것 처럼 `Stateless`의 경우 클라이언트가 서버에 요청시 데이터 양이 많음!
- 웹 애플리케이션 개발 시 최대한 `Stateless`로 개발을 한다는 점을 알아두자!
	- 당연하지만 어쩔 수 없는 상황엔 `Stateful`로 개발을 하기도 한다 (매우 드뭄)  
<br/><br/><br/>

## 04. 비 연결성 (connectionless)
### 연결을 유지하는 모델
- 클라이언트와 서버가 항시 연결되어 있음
- `클라이언트 1, 2, 3`과 `서버`가 있을 때 순차적으로 `클라이언트 - 서버` 사이에 요청/응답이 진행 했다면
	- 이미 요청/응답이 끝난 `클라이언트 1, 2`은 아직 `서버`와 연결이 유지되어 있음\
	- 즉, `서버 자원을 계속 소모 중`이라는 뜻이다.  
<br/>

### 연결을 유지하지 않는 모델
- 클라이언트와 서버가 요청/응답을 주고 받을 때만 연결을 유지함
	- 이미 요청/응답이 끝난 `클라이언트`와 연결을 유지하지 않음
	- 즉, 서버 자원 소모가 없으므로 `최소한의 자원을 사용`한다.  
<br/>

### 비 연결성
- `HTTP`는 기본적으로 연결을 유지하지 않는 모델
- 보통 초 단위 이하의 빠른 속도로 응답이 이루어짐
	- 설령 수 천명이 동시에 서비스를 이용해도 자세히 보면 동시 처리하는 요청은 수 십개 이하로 적음
	- ex) 웹 브라우저에서 검색 후 바로 다른 걸 검색하는게 아닌 점 (검색을 연타하지 않음)
- 서버 자원을 매우 효율적으로 사용할 수 있음  
<br/>

#### 한계와 극복
하지만 `단점`도 분명 존재한다.
- `TCP/IP` 연결을 새로 맺어야 하는 점 - 다시 `3 way handshake`를 수행하는 시간 추가
- 웹 브라우저 이용시 `HTML`뿐 아니라 `자바스크립트` `css` `추가 이미지` 등 수 많은 자원을 함께 다운로드 됨
	- 웹 사이트를 띄우는데 필요한 자원을 다운로드 할 때마다 `연결/종료`가 반복됨
	- 필요한 자원의 수가 적지 않아 낭비되는 자원이 상당함
- 현재는 `HTTP 지속 연결(Persistent Connections)`로 문제 해결
	- `HTTP/2`와 `HTTP/3`에서는 더 많은 최적화가 이루어짐  
<br/>

### HTTP 지속 연결 (Persistent Connections)
-  HTTP 초기 : 연결/종료로 인한 자원 낭비
- 현재 : `HTTP 지속 연결`을 통해 `연결/종료`의 작업을 줄인만큼 자원을 아끼게 됨  
<br/>

### Stateless를 기억하자 
#### 서버 개발자들이 어려워하는 업무
- 정말 같은 시간에 딱 맞춰 발생하는 대용량 트래픽에 대한 업무
	- ex) 선착순 이벤트, 수강 신청, 콘서트 티켓 예매 등
	- `HTTP 지속 연결`이 의미 없을 정도, 정말로 그 시간에 딱 맞춰 다수의 클라이언트가 접속하기 때문에 
- 즉,  `Stateless`하게 개발을 해서 `서버증설`을 통해 대응 할 수 있어야 함!