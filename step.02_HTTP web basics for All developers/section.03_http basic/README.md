# 섹션 03. HTTP 기본
## 01. 모든 것이 HTTP (HyperText Transfer Protocol)
### HTTP 메시지에 모든 것을 전송
- HTML, TEXT
- 이미지, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터들을 전송 가능
- 서버간 데이터를 주고 받을 떄도 대부분 HTTP 사용
- 바야흐로 대 HTTP 시대!  
<br/>

### HTTP 역사
- `HTTP/0.9` (1991) : GET 메서드만 지원
- `HTTP/1.0` (1996) : 메서드, 헤더 추가
- `HTTP/1.1` (1997) : __가장 많이 사용하는 버전 (= 중요한 버전)__
	- RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- `HTTP/2` (2015) : 성능 개선
- `HTTP/3` (개발중) : TCP 대신 UDP 사용, 성능 개선  
<br/>

### 기반 프로토콜
- `TCP` : HTTP/1.1 ~ HTTP/2
	- `TCP` 자체가 속도에 최적화 된 프로토콜이 아님
- `UDP` : HTTP/3
- 현재 `HTTP/1.1`을 주로 사용
	- 하지만 `HTTP/2` `HTTP/3`도 점점 증가 추세  
<br/>

### HTTP 특징
- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능  
<br/><br/><br/>

## 02. 클라이언트 서버 구조
- Request & Response 구조
- 클라이언트는 서버에 요청을 보내고 응답을 대기함
- 서버가 요청에 대한 결과를 만들어 응답
- 사실 클라이언트와 서버를 분리했다는게 중요!  
<br/><br/><br/>

## 03. Stateful, Stateless
### Stateful과 Stateless의 차이
#### Stateful의 경우 - 상태 유지
- 예제
	- 고객 : 노트북 얼마인가요?
	- 점원 : 100만원 입니다. __(노트북 상태 유지)__
	- 고객 : 2개 구매 할 수 있을까요?
	- 점원 : 네! 200만원 입니다. 결제를 뭐로 하시겠어요? __(노트북, 2개 상태 유지)__
	- 고객 : 신용카드로 결제 할게요.
	- 점원 : 네 결제 완료 되었습니다. __(노트북, 2개, 신용카드 상태 유지)__
- 우리가 아는 흔한 일상 대화이다.  
<br/>

#### Stateless의 경우 - 무상태
- 예제
	- 고객 : __노트북__ 얼마인가요?
	- 점원(1) : 100만원 입니다.
	- 고객 : __노트북 2개__ 구매 할 수 있을까요?
	- 점원(2) : 네! 200만원 입니다. 결제를 뭐로 하시겠어요?
	- 고객 : __노트북 2개 신용카드로__ 결제 할게요.
	- 점원(3) : 네 결제 완료 되었습니다.
- 고객이 말하는 내용이 점차 늘어나지만 예제처럼 점원이 바뀌어도 일처리에 문제가 없음  
<br/>

### Stateless(스테이트리스) - 무상태 프로토콜
- 서버가 클라이언트의 상태를 보존하지 않음
	- 장점 : 서버의 확장성이 높음 (스케일 아웃)
	- 단점 : 클라이언트가 추가 데이터 전송  
<br/>

### 정리
- `상태 유지(Stateful)` : 중간에 다른 점원으로 바뀌면 안됨!
- `무상태(Stateless)` : 중간에 다른 점원으로 바뀌어도 상관 없음!
	- 갑자기 고객이 많아져도 점원만 추가하면 됨
		- 즉, 클라이언트 수가 급격하게 많아져도 서버만 추가하면 된다.
- `Stateless`의 경우 응답 서버를 쉽게 바꿀 수 있음
	- (이론상)무한한 서버 증설 가능!!
- 중간에 서버가 장애가 난다면?
	- `Stateful`의 경우 요청을 처음부터 다시 작성해야함
	- `Stateless`의 경우 기존 요청을 다른 서버에게 건네주기만 하면 됨
		- 이러한 점 때문에 `Stateless`의 경우 `스케일 아웃(수평 확장)`이 유리하다!
- `Stateless`의 실무 한계
	- 모든 것을 무상태로 설계 할 수 있는 경우가 있고 없는 경우가 있다는 점
		- ex) 로그인이 필요없는 안내 페이지 (무상태)
		- ex) 로그인 해야 참여가 가능한 페이지 (상태 유지)
	- 로그인한 사용자의 상태를 서버에 유지를 해야함
		- 그렇기에 `브라우저 쿠키`와 `서버 세션`등을 사용해 상태를 유지함
	- 또한 상태 유지를 최소한만 사용해야함
		- 이전에 예시를 들었던 것 처럼 `Stateless`의 경우 클라이언트가 서버에 요청시 데이터 양이 많음!
- 웹 애플리케이션 개발 시 최대한 `Stateless`로 개발을 한다는 점을 알아두자!
	- 당연하지만 어쩔 수 없는 상황엔 `Stateful`로 개발을 하기도 한다 (매우 드뭄)  
<br/><br/><br/>

## 04. 비 연결성 (connectionless)
### 연결을 유지하는 모델
- 클라이언트와 서버가 항시 연결되어 있음
- `클라이언트 1, 2, 3`과 `서버`가 있을 때 순차적으로 `클라이언트 - 서버` 사이에 요청/응답이 진행 했다면
	- 이미 요청/응답이 끝난 `클라이언트 1, 2`은 아직 `서버`와 연결이 유지되어 있음\
	- 즉, `서버 자원을 계속 소모 중`이라는 뜻이다.  
<br/>

### 연결을 유지하지 않는 모델
- 클라이언트와 서버가 요청/응답을 주고 받을 때만 연결을 유지함
	- 이미 요청/응답이 끝난 `클라이언트`와 연결을 유지하지 않음
	- 즉, 서버 자원 소모가 없으므로 `최소한의 자원을 사용`한다.  
<br/>

### 비 연결성
- `HTTP`는 기본적으로 연결을 유지하지 않는 모델
- 보통 초 단위 이하의 빠른 속도로 응답이 이루어짐
	- 설령 수 천명이 동시에 서비스를 이용해도 자세히 보면 동시 처리하는 요청은 수 십개 이하로 적음
	- ex) 웹 브라우저에서 검색 후 바로 다른 걸 검색하는게 아닌 점 (검색을 연타하지 않음)
- 서버 자원을 매우 효율적으로 사용할 수 있음  
<br/>

#### 한계와 극복
하지만 `단점`도 분명 존재한다.
- `TCP/IP` 연결을 새로 맺어야 하는 점 - 다시 `3 way handshake`를 수행하는 시간 추가
- 웹 브라우저 이용시 `HTML`뿐 아니라 `자바스크립트` `css` `추가 이미지` 등 수 많은 자원을 함께 다운로드 됨
	- 웹 사이트를 띄우는데 필요한 자원을 다운로드 할 때마다 `연결/종료`가 반복됨
	- 필요한 자원의 수가 적지 않아 낭비되는 자원이 상당함
- 현재는 `HTTP 지속 연결(Persistent Connections)`로 문제 해결
	- `HTTP/2`와 `HTTP/3`에서는 더 많은 최적화가 이루어짐  
<br/>

### HTTP 지속 연결 (Persistent Connections)
-  HTTP 초기 : 연결/종료로 인한 자원 낭비
- 현재 : `HTTP 지속 연결`을 통해 `연결/종료`의 작업을 줄인만큼 자원을 아끼게 됨  
<br/>

### Stateless를 기억하자 
#### 서버 개발자들이 어려워하는 업무
- 정말 같은 시간에 딱 맞춰 발생하는 대용량 트래픽에 대한 업무
	- ex) 선착순 이벤트, 수강 신청, 콘서트 티켓 예매 등
	- `HTTP 지속 연결`이 의미 없을 정도, 정말로 그 시간에 딱 맞춰 다수의 클라이언트가 접속하기 때문에 
- 즉,  `Stateless`하게 개발을 해서 `서버증설`을 통해 대응 할 수 있어야 함!  
<br/><br/><br/>

## 05. HTTP 메시지
### HTTP 메시지 구조
위에서 순차적으로 보면 아래와 같은 구조로 작성된다.
1. `start-line` : 시작 라인
2. `header` : 헤더
3. `empty line` : 공백 라인 (CRLF), 반드시 필요함!
4. `message body` : 메시지 내용 (HTML)  
<br/>

#### HTTP 요청 메시지 - 예시
```
GET /search?q=hello&hl=ko HTTP/1.1	[시작 라인]
Host: www.google.com			[헤더]
					[공백 라인]
```
- 물론 `요청 메시지`의 경우도 `message body`를 가질 수 있음  
<br/>

#### HTTP 응답 메시지 - 예시
```
HTTP/1.1 200 OK				[시작 라인]
Content-Type: text/html;charset=UTF-8	[헤더]
Content-Length: 3423			[/헤더]
					[공백 라인]
<html>					[message body]
<body>...</body>
</html>					[/message body]
```
__[공식 스펙](https://tools.ietf.org/html/rfc7230#section-3)__ 
```
HTTP-message   = start-line
		*( header-field CRLF )
		CRLF
		[ message-body ]
```  
<br/>

### 시작 라인 - start-line
#### 요청 메시지 (request-line) 구조
- __request-line__ = `method` `SP(공백)`	`request-target` `SP` `HTTP-version` `CRLF(엔터)`
	- `method` : `HTTP 메서드`를 적음, `GET` `PUT` `DELETE` `POST` 등
		- 서버가 수행해야 할 동작을 지정함
		- `GET(리소스 조회)` `POST(요청 내역 처리)`
	- `request-target` : 요청 대상을 적음
		- `absolute-path[?query]` : `절대경로[?쿼리]`
		- `absolute-path(절대 경로)` : `"/"`로 시작하는 경로
		- __참고!__ : `*` `http://...?x=y` 와 같이 다른 유형의 경로지정 방법 있음
	- `HTTP-version` : HTTP의 버전을 적음  
<br/>

#### 응답 메시지 (status-line) 구조
- __status-line__ = `HTTP-version` `SP` `status-code` `SP` `reason-phrase` `CRLF`
	- `status-code` : HTTP 상태 코드 (요청에 대한 성공/실패를 나타냄)
		- __200__ : 성공
		- __400__ : 클라이언트 요청 오류
		- __500__ : 서버 내부 오류
	- `reason-phrase` : __이유 문구__(상태코드에 대한 짧은 설명)  
<br/>

### HTTP 헤더
#### 구조
- __header-field__ = `field-name` `":"` `OWS` `field-value` `OWS` <sub>__(OWS:띄어쓰기 허용)__</sub>
	- `주의!` : `필드명 :`은 안 됨, 반드시 `필드명:` 이어야함
		- 필드명 이후 `":"`은 공백없이 필드명에 붙여써야 함
	- `field-name` : 영대소문자 구분 없음
	- `field-value` : 영대소문자 구분 있음  
<br/>

#### 용도
- HTTP 전송에 필요한 `모든 부가정보`
	- ex) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보 등
	- `message body`를 제외한 `필요 메타 데이터 정보`가 다 들어 있다고 봐도 무방!
- [표준 헤더](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)는 정말 많음!
- 필요시 임의 헤더를 추가 가능
	- ex) helloworld: HiHi
	- 물론 사용을 위해선 클라이언트와 서버간 `약속`이 필요  
<br/>

### HTTP 메시지 바디
#### 용도
- 실제 전송할 데이터
- `HTML 문서` `이미지` `영상` `JSON` 등 `byte로 표현할 수 있는 모든 데이터` 전송 가능!