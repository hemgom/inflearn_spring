# 섹션 01. 객체 지향 설계와 스프링

### 01. 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생
- EJB -> Enterprise Java Beans
  - 기술 영업의 근간이 되는 `표준 기술`
  - 당시 `오픈 소스`는 영업에 불리한 기술로 치부됬음
  - 종합 선물세트 같은 존재이나 굉장히 고가였음
  - 단점이 `지옥급`, 난이도 극상, 인터페이스 의존성이 너무 높음

- 비효율적인 EJB 때문에 `선구자`들이 하나 둘 등장함
  - 스프링의 근간이 되는 오픈소스들이 등장
    - `Rod Johnson` - 'expoert one-on-one J2EE Design and Development`의 저자
    - `EJB 컨테이너`를 비판하고 대체하는 오픈소스 기술을 발전시킴
  - `EJB 엔티티빈` -(등장)-> `하이버네이트` -(자바표준, 정제)-> `JPA`

- `실용성`과 표준이라는 말에서 오는 `안정성` 둘을 모두 잡은 `JPA`

- 스프링의 역사(a.k.a 전설의 시작)
  - 2002년 로드 존슨이 책 'expoert one-on-one J2EE Design and Development`을 출간
    - EJB의 문제점 지적
    - EJB이 없이 충분히 고품질의 확장 가능한 애플리케이션 개발이 가능함을 보여줌
    - 3만 라인 이상의 기반 기술을 예제 코드로 입증
    - 현재의 스프링 핵심 개념과 기반 코드가 녹아 있음
    - BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입 등
  - 이후 `Juergen Hoeller(유겐 휠러)`, `Yann Caroff(얀 카로프)`가 로드 존슨에게 오픈소스 프로젝트 제안
    - 스프링의 핵심 코드의 상당 수는 유겐 휠러가 지금도 개발
    - `스프링`이란 이름은 전통적인 `J2EE(EJB)`라는 겨울을 넘어 새로운 시작이라는 뜻으로 지어졌음
  - 릴리즈
    - 2003년 스프링 프레임워크 1.0 출시 - XML
    - 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
    - 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
    - 2013년 스프링 프레임워크 4.0 출시 - 자바 8
    - 2014년 스프링 부트 1.0 출시 - 새로운 전환점
    - 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원
    - 2020년 9월 스프링 프레임워크 5.2.x, 스프링 부트 2.3.x



### 02. 스프링이란?
- 스프링 생태계
  - 필수 : `스프링 프레임 워크` `스프링 부트`
  - 선택 : `스프링 데이터` `스프링 세션` `스프링 시큐리티` `스프링 Rest Docs` `스프링 배치` `스프링 클라우드`
  - https://spring.io/projects : 스프링 관련 프로젝트를 볼 수 있음

- 스프링 프레임워크
  - 핵심 기술 : `스프링 DI 컨테이너` `AOP` `이벤트` 등
  - 웹 기술 : `스프링 MVC` `스프링 WebFlux`
  - 데이터 접근 기술 : `트랜잭션` `JDBC` `ORM 지원` `XML 지원`
  - 기술 통합 : `캐시` `이메일` `원격접근` `스케줄링`
  - 테스트 : `스프링 기반 테스트 지원`
  - 언어 : `코틀린` `그루비`
  - 현재 `스프링 부트`를 통해 스프링 프레임워크의 기술들을 편리하게 사용 가능함

- 스프링 부트
  - 스프링을 편리하게 사용할 수 있도록 지원하는 기술, 현재에는 `스프링 부트` 사용이 기본이다.
  - 단독으로 실행 가능한 스프링 애플리케이션을 쉽게 생성 가능
  - `Tomcat` 같은 웹 서버를 내장해 별도의 웹 서버 설치가 불필요
  - 손쉬운 빌드 구성을 위해 `starter` 종속성 제공
  - `스프링`과 `3rd parth(외부)` 라이브러리 자동 구성
  - `메트릭` `상태 확인` `외부 구성` 같은 프로덕션 준비 기능 제공
  - 관례에 의한 간결한 설정으로 인해 설정의 난이도가 확 내려감

- 스프링이란 단어? - 이름은 하난데 별명의 서너개
  - `스프링`이란 단어는 문맥에 따라 다르게 사용됨, 오피셜 내용
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계
  - 결국 언급하는 상황에 따라 의미하는 바가 다를 수 있음을 알아두자!

- 스프링은 왜 만들었나?
  - 스프링의 핵심 개념, 컨셉?
    - 자바 언어 기반의 프레임워크
    - 자바 언어의 가장 큰 특징 - 객체 지향 언어
    - 객체 지향 언어가 가진 강력한 특징을 살릴 수 있는 프레임워크
    - 즉, `좋은 객체 지향 애플리케이션` 개발을 가능하게하는 프레임워크!



### 03. 좋은 객체 지향 프로그래밍이란?
- 객체 지향 특징 : `추상화` `캡슐화` `상속` `다형성`

- 객체 지향 프로그래밍
  - 컴퓨터 프로그램을 명령어의 목록으로 보는 시간에서 벗어나 여러개의 독립된 단위, 즉 `객체들의 모임`으로 파악하고자 하는 것
  - 각각의 `객체`는 `메시지`를 주고받고, 데이터를 처리할 수 있다.
  - 프로그램을 `유연`하고 `변경`이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됨

- 유연하고 변경이 용이? : 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
  - 다형성(Polymorphism)

- 다형성의 실세계 비유
  - `역할`과 `구현`으로 세상을 구분 -> 세상이 `단순`해지고, `유연`해지며 `변경`도 편리해짐
  - 역할을 구분한다면 특정 역할의 구현이 달라져도 특정 역할 외의 역할에는 영향이 거의 없다.
  - 즉, 구현에 있어 확장 범위에 제한이 없어짐
  - 장점
    - 클라이언트는 대상의 `역할(인터페이스)`만 알면 됨
    - 클라이언트는 구형 대상의 `내부 구조를 몰라도` 됨
    - 클라이언트는 구현 대상의 `내부 구조가 변경`되어도 `영향을 받지 않음`
    - 클라이언트는 구현 `대상 자체를 변경`해도 `영향을 받지 않음`

- 자바 관점에서 역할과 구현을 분리
  - 자바 언어의 다형성
    - `역할 == 인터페이스` `구현 == 인터페이스를 구현한 클래스, 구현 객체`
  - 객체 설계 시 `역할`과 `구현`을 명확히 구분
    - `역할(인터페이스)`을 먼저 부여 후에 역할을 수행하는 `구현 객체` 만들기
  - 정리
    - 편리한 컨셉을 `다형성`을 통해 객체 세상으로 가져오는게 가능
    - `유연`하며 `변경 용이` `확장 가능한 설계`
    - 클라이언트에게 `영향을 주지 않는 변경` 가능
    - 인터페이스를 안정적으로 설계하는 것이 중요
  - 한계
    - 역할(인터페이스) 자체가 변할 경우 클라이언트와 서버 모두에 큰 변경이 불가피함
    - 결국 `안정적인 인터페이스 설계`가 너무나도 중요함

- 객체의 협력이라는 관계부터 생각하자
  - 단일 객체는 없다!
  - `요청(클라이언트)`이 있으면 `응답(서버)`이 있어야 함
  - 수 많은 객체 클라이언트와 객체 서버는 서로 `협력 관계`를 가짐

- 자바 언어의 다형성
  - 대표적인 예시로 `오버라이딩`
  - 인터페이스를 구현한 객체를 실행 시점에 연하게 변경이 가능함
  - 물론 클래스 상속 관계도 `다형성` `오버라이딩` 적용가능

- 다형성의 본질
  - 인터페이스를 구현한 객체 인스턴스를 `실행 시점`에 `유연`하게 `변경`할 수 있음
  - 다형성의 본질을 이해하기 위해 `협력`이라는 객체사이의 관계에서 시작해야함
  - 클라이언트를 `변경하지 않고`, 서버의 구현 기능을 `유연하게 변경 가능`함

- 스프링과 객체 지향
  - `다형성`이 가장 중요!
  - 스프링은 다형성을 `극대화`해 활용할 수 있게 도움
  - 스프링에서의 `제어의 역전(IoC)` `의존관계주입(DI)`는 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있게 지원함
  - 스프링을 사용한다면 구현을 편리하게 변경할 수 있음



### 04. 좋은 객체 지향 설계의 5가지 원칙(SOLID)
- SOLID : 클린코드로 유명한 `로버트 마틴`이 좋은 객체 지향 설계의 5자기 원칙을 정리
  - SRP(single repsonsibility principle) : 단일 책임 원칙
  - OCP(open/closed principle) : 개방/폐쇠 원칙
  - LSP(liskov substitution principle) : 리스코프 치환 원칙
  - ISP(interface segregation principle) : 인터페이스 분리 원칙
  - DIP(dependency inversion principle) : 의존관계 역전 원칙

- SRP(단일 책임 원칙)
  - 한 클래스는 하나의 책임만 가져야함
  - 그러나 `하나의 책임`이라는 것이 모호함
    - 크거나 작을 수 있으며 문맥과 상황에 따라 바뀜
  - 그러나 중요한 기준은 `변경`, 변경이 있을 때 `적은 파급 효과`가 해당 원칙을 잘 따랐다고 할 수 있음

- OCP(개방/폐쇠 원칙)
  - 소프트웨어 요소는 `확장에는 열려` 있으나 `변경에는 닫혀` 있어야 함
  - `다형성`을 활용하면 이해가 쉬움 -> 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하는 경우
  - 문제점
    - `MemberService 클라이언트`가 구현 클래스를 직접 선택
      - 기존 코드 : `MemberRepository m = new MemoryMemberRepository();`
      - 변경 코드 : `MemberRepository m = new JdbcMemberRepository();
    - `구현 객체 변경` 시 `클라이언트 코드 변경`을 해야 함
    - `다형성`을 사용했으나 `OCP 원칙`을 지킬 수 없는 아이러니 상황
    - 이러한 문제점을 해결하기 위해서 객체를 생성하고 연관 관계를 맺어주는 별도의 `조립` `설정자`가 필요함

- LSP(리스코프 치환 원칙)
  - 프로그램의 객체는 프로그램의 `정확성`을 깨뜨리지 않으면서 하위 타입의 인스턴스를 변경 가능해야 함
  - 다형성에서 `하위 클래스는 인터페이스 규약을 다 지켜야는 원칙` `다형성 지원하기 위한 원칙` `인터페이스 구현제를 믿고 사용하기 위한 원칙`

- ISP(인터페이스 분리 원칙)
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
  - 인터페이스가 명확해지고 대체 가능성이 높아 짐

- DIP(의존관계 역전 원칙)
  - `"프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다."`
  - 즉 구현 클래스에 의존하지 말고 `인터페이스에 의존`하라는 뜻
  - 클라이언트가 인터페이스에 의존해야 유연하게 구현체 변경이 가능함, 구현체에 의존 시 변경이 어려워짐
  - 하지만 OCP에서 설명한 `MemberService`는 `인터페이스`와 `구현 클래스` 둘 다 의존하고 있다 -> 이는 DIP 위반

- 정리
  - 객체 지향의 핵심은 `다향성`
  - 하지만, 다형성만으로는 `OCP` `DIP`를 지킬 수 없음
    - 다형성만으로는 쉽게 레고나 부품을 갈아 끼우듯 개발이 불가능
    - 다형성만 있을 땐 구현 객체 변경 시 클라이언트도 함께 변경이 필요함
    - 결국 `다형성 외의 뭔가가 더 필요함`을 알 수 있음