# 섹션 03. 트랜잭션 이해
## 01. 트랜잭션 - 개념 이해
### 데이터베이스에 데이터를 저장하는 이유?
데이터 베이스가 `트랜잭션`이라는 개념을 지원하기 때문!  
- `트랜잭션`: 직역하면 `거래`라는 뜻이며, 여기서는 하나의 `거래를 안전하게 처리`하도록 보장해주는 것을 뜻함
  - `안전한 거래 처리`: 예를 들어 `A`가 `B`에게 `5,000원`을 계좌이체 할 때 [`A`: `-5,000`, `B`: `+5,000`]
  - 잔고의 감소와 증가가 합쳐저 하나의 작업처럼 동작해야 함
  - 두 작업(감소, 증가)이 `모두 성공`하면 저장, `둘 중 한 작업이라도 실패`한다면 이전 상태로 돌아가야 함
    - `커밋(Commit)`: 모든 작업이 성공해 DB에 정상 반영
    - `롤백(Rollback)`: 둘 중 하나라도 작업이 실패해 이전으로 되돌리는 것  
<br/>

### 트랜잭션 ACID
트랜잭션은 `ACID`라고 하는 `원자성(Atomicity)`, `일관성(Consistency)`, `격리성(Isolation)`, `지속성(Durability)`을 보장해야 함
- `원자성`: 트랜잭션 내, 실행 작업들은 `하나의 작업`처럼 모두 성공하거나 모두 실패해야 함
- `일관성`: 모든 트랜잭션은 `일관성 있는 DB 상태`를 유지해야 함
  - ex) DB에서 정한 `무결성 제약 조건`을 항상 만족해야 함
- `격리성`: 동시에 실행되는 트랜잭션들이 `서로 영향을 미치지 않게` 격리함
  - ex) 동시에 같은 데이터를 수정하지 못하도록 해야함
  - 동시성과 관련된 성능 이슈로 인하여 `트랜잭션 격리 수준(Isolation level)`을 선택 가능함
- `지속성`: 트랜잭션 성공시 항상 결과를 기록하여야 함
  - 작업 중간에 시스템 문제가 발생해도 DB 로그 등을 사용해 성공한 트랜잭션 내용을 복구해야 함  
<br/>

### 문제는 격리성
트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성이며 이를 완벽하게 보장하려면 트랜잭션은 거의 순서대로 실행해야 한다.
- 하지만 완벽히 보장할 경우 `동시 처리 성능`이 매우 떨어진다.
- 그렇기에 `ANSI 표준`에서는 트랜잭션의 격리 수준을 4단계에 나누어 정의함
  1. READ UNCOMMITTED (커밋되지 않은 읽기)
  2. READ COMMITTED (커밋된 읽기) -> `일반적으로 많이 사용`
  3. REPEATABLE READ (반복 가능한 읽기)
  4. SERIALIZABLE (직렬화 가능)  
<br/><br/><br/>

## 02. 데이터베이스 연결 구조와 DB 세션
#### 데이터베이스 연결 구조1
![img_001](img/img_001.jpg)
- 사용자는 `웹 애플리케이션 서버(WAS)`나 `DB 접근 툴`같은 클라이언트를 사용해 DB 서버에 접근 가능함
  - DB 서버에 연결을 요청 -> 커넥션을 맺게 됨
  - 이 때, DB 서버는 내부에 `세션`이라는 것을 생성
  - 해당 커넥션을 통한 모든 요청이 `세션`을 통해 실행하게 됨
- 개발자가 클라이언트를 통해 `SQL`을 전달하면 현재 커넥션에 연결된 `세션`이 `SQL`을 실행함
- `세션`: 트랜잭션 시작, 커밋/롤백을 통해 트랜잭션을 종료, 새로운 트랜잭션 시작이 가능함
- 사용자가 커넥션을 닫거나 DBA(DB 관리자)가 세션을 강제 종료하면 세션이 종료됨  
<br/>

#### 데이터베이스 연결 구조2
![img_002](img/img_002.jpg)
- 커넥션 풀이 10개의 커넥션을 생성할 경우 세션 또한 10개가 만들어짐  
<br/><br/><br/>

## 03. 트랜잭션 - DB 예제1 - 개념 이해
아래의 예제는 `트랜잭션의 동작 개념의 전체 그림`을 이해하기 위해 작성됨
- 구체적인 구현같은 경우 데이터베이스 마다 다르기 때문이다.  
<br/>

### 트랜잭션 사용법
- 데이터 변경 쿼리 실행 --(`commit` 명령어 호출)--> 결과 반영
- 데이터 변경 쿼리 실행 --(`rollback` 명령어 호출)--> 결과 반영 X
- `커밋 호출 전까진 임시로 데이터를 저장`
  - 이 때 해당 트랜잭션을 시작한 사용자(세션)에게만 변경 데이터가 보임
  - 다른 사용자(세션)에게는 변경데이터가 보이지 않음
- 등록, 수정, 삭제 모두 같은 원리로 동작함 -> 통틀어 `변경`이라고 지칭  
<br/>

#### 기본 데이터
![img_003](img/img_003.jpg)
- 각 세션에서 그림의 가운데 위치한 `기본 테이블` 조회시 해당 데이터가 그대로 조회됨  
<br/>

#### 세션1 신규 데이터 추가
![img_004](img/img_004.jpg)
- 세션1은 트랜잭션을 시작하고 신규 회원1, 신규회원2를 DB에 추가함(커밋X)
  - 이 때 새로운 데이터는 임시 상태로 저장됨
- 아직 커밋을 하지 않았기에 각 세션이 조회할 수 있는 데이터는 아래와 같음
  - `세션1`: 기본 테이블 데이터 + 본인이 추가한 데이터
  - `세션2`: 기본 테이블 데이터  
<br/>

#### 커밋하지 않은 데이터를 다른 곳에서 조회 가능할 경우 발생하는 문제
- 세션2가 세션1이 추가한 데이터에 대해서 어떤 로직을 수행 --(세션1 rollback)--> 세션2도 데이터 증발
  - 이렇게 데이터 정합성에 큰 문제가 발생할 수 있음  
<br/>

#### 세션1 신규 데이터 추가 후 commit
![img_005](img/img_005.jpg)
- 세션1이 신규 데이터를 추가하고 `commit`을 호출 -> 실제 DB에 신규 데이터 반영
  - 데이터 상태가 `임시 -> 완료`로 바뀜
  - 세션2에서도 신규 데이터를 확인 가능  
<br/>

#### 세션1 신규 데이터 추가 후 rollback
![img_006](img/img_006.jpg)
- 세션1이 신규 데이터 추가 후 `rollback` 호출 -> 신규 데이터 추가 이전으로 데이터가 복구됨
  - `변경` 데이터는 종류(수정, 삭제 등)를 불문하고 트랜잭션 시작 직전의 상태로 복구됨